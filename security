# Security Checklist for Next.js + React + Supabase Web Applications

## Input Validation & Injection Prevention
- **Validate and Sanitize Inputs:** Never trust user input. Always validate and sanitize data on the server before using it (e.g., with a schema validation library like Zod) ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=Never%20trust%20user%20input,for%20schema%20validation%20to%20enhance)). This prevents malicious inputs from causing SQL injection or other injection attacks ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=Never%20trust%20user%20input,for%20schema%20validation%20to%20enhance)). Use ORM or parameterized queries (Supabase’s query builder, Prisma, etc.) instead of constructing SQL strings directly, to ensure queries are safe and not prone to injection ([What are some best practices for cybersecurity in Next.js? : r/nextjs](https://www.reddit.com/r/nextjs/comments/1embc8l/what_are_some_best_practices_for_cybersecurity_in/#:~:text=%2A%20Set%20CORS%2C%20CSP%2C%20X,Policies)).

## Preventing Cross-Site Scripting (XSS)
- **Escape or Sanitize Outputs:** Avoid rendering any user-supplied data as HTML without proper sanitization. Never use dangerous functions like `dangerouslySetInnerHTML` with unsanitized content ([What are some best practices for cybersecurity in Next.js? : r/nextjs](https://www.reddit.com/r/nextjs/comments/1embc8l/what_are_some_best_practices_for_cybersecurity_in/#:~:text=)). By default, React escapes content to mitigate XSS, so rely on that and utilize a library (e.g. DOMPurify) if you must insert raw HTML, to sanitize any untrusted content.
- **Content Security Policy:** Define a strict Content Security Policy (CSP) header to limit the sources of scripts and other resources in your app, providing a safety net against XSS ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=configurations%20to%20identify%20and%20address,logs%20for%20any%20suspicious%20activity)). A CSP helps block unauthorized scripts from executing, even if an XSS vulnerability is present, by only allowing content from trusted origins ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=configurations%20to%20identify%20and%20address,logs%20for%20any%20suspicious%20activity)).
- **Secure Cookies (HttpOnly & Secure):** Use HttpOnly cookies for session tokens so that even if XSS occurs, malicious scripts cannot access them ([Next-level security: how to hack-proof your Next.js applications](https://www.vintasoftware.com/blog/security-nextjs-applications#:~:text=One%20common%20practice%20when%20using,are%20only%20transmitted%20over%20HTTPS)). Also mark cookies with the `Secure` flag (so they are only sent over HTTPS) to prevent man-in-the-middle interception ([Next-level security: how to hack-proof your Next.js applications](https://www.vintasoftware.com/blog/security-nextjs-applications#:~:text=One%20common%20practice%20when%20using,are%20only%20transmitted%20over%20HTTPS)). These attributes help protect session cookies from client-side scripts and eavesdroppers.

## Cross-Site Request Forgery (CSRF) Protection
- **SameSite Cookies:** Set cookies (especially session cookies) with `SameSite=Lax` or `SameSite=Strict` to reduce the risk of them being sent in cross-site requests ([Protecting Next.js apps from CSRF attacks - LogRocket Blog](https://blog.logrocket.com/protecting-next-js-apps-csrf-attacks/#:~:text=A%20possible%20way%20to%20protect,site%20request%20forgery)). With the SameSite attribute in effect, the browser will not include your session cookie on most cross-site requests, thereby blocking many CSRF attack attempts by default ([Protecting Next.js apps from CSRF attacks - LogRocket Blog](https://blog.logrocket.com/protecting-next-js-apps-csrf-attacks/#:~:text=A%20possible%20way%20to%20protect,site%20request%20forgery)).
- **CSRF Tokens for State-Changing Requests:** Implement anti-CSRF tokens for form submissions and any state-changing HTTP requests ([Next-level security: how to hack-proof your Next.js applications](https://www.vintasoftware.com/blog/security-nextjs-applications#:~:text=A%20solution%20for%20that%20is,and%20data%20sanitization%20is%20crucial)). The server should verify that each such request includes a valid token that your frontend generated, ensuring the request came from your application and not a malicious site ([Next-level security: how to hack-proof your Next.js applications](https://www.vintasoftware.com/blog/security-nextjs-applications#:~:text=A%20solution%20for%20that%20is,and%20data%20sanitization%20is%20crucial)). Reject requests that lack a proper CSRF token or have an invalid token (e.g. respond with HTTP 403), to block CSRF attacks ([Next-level security: how to hack-proof your Next.js applications](https://www.vintasoftware.com/blog/security-nextjs-applications#:~:text=CSRF%20attacks%20exploit%20authenticated%20users,unwanted%20operations%20on%20their%20behalf)).

## Authentication & Session Security
- **Secure Authentication Flow:** Use proven authentication solutions (e.g. Supabase Auth or NextAuth) and avoid writing custom auth from scratch unless necessary. Ensure passwords are never stored in plain text (Supabase’s auth will hash them by default) and enforce strong password policies. For critical accounts or admin users, consider adding multi-factor authentication. In any login flow, implement brute-force protections (like limiting failed login attempts).
- **HTTP-Only Session Cookies:** Manage user sessions with secure, HTTP-only cookies when possible ([Next-level security: how to hack-proof your Next.js applications](https://www.vintasoftware.com/blog/security-nextjs-applications#:~:text=One%20common%20practice%20when%20using,are%20only%20transmitted%20over%20HTTPS)). Cookies should have the `HttpOnly` and `Secure` flags to prevent access via JavaScript and to ensure they’re only transmitted over HTTPS ([Next-level security: how to hack-proof your Next.js applications](https://www.vintasoftware.com/blog/security-nextjs-applications#:~:text=One%20common%20practice%20when%20using,are%20only%20transmitted%20over%20HTTPS)). This setup guards session tokens from theft via XSS and network sniffing.
- **JWT Expiration & Refresh:** If using JWTs for authentication, configure short expiration times for access tokens (ideally minutes or hours, not days) ([JWT Security Best Practices | Curity](https://curity.io/resources/learn/jwt-best-practices/#:~:text=short%20an%20expiration%20time%20for,valid%20for%20days%20or%20months)). Short-lived tokens minimize the window in which a stolen token can be abused ([JWT Security Best Practices | Curity](https://curity.io/resources/learn/jwt-best-practices/#:~:text=short%20an%20expiration%20time%20for,valid%20for%20days%20or%20months)). Implement a refresh token mechanism or re-authentication flow to obtain new tokens when needed, rather than using long-lived JWTs. Always verify the token’s signature and `exp` claim on the server for each request, and handle expired tokens gracefully (e.g., prompt login or use refresh logic).
- **Session Management Best Practices:** Tie sessions or JWTs to a single user context and device (avoid sharing tokens between users or using one token for multiple purposes). Invalidate session tokens on logout and consider automatic expiration (idle timeout) for inactive sessions. Store authentication secrets (JWT signing keys, OAuth client secrets) securely on the server, and rotate them if a breach is suspected or on a regular schedule for good hygiene.

## Authorization & Access Control 
- **Enforce Row-Level Security (RLS):** Enable Postgres Row Level Security on all Supabase tables containing user data and define policies to ensure each user can only access their own records ([Securing your API | Supabase Docs](https://supabase.com/docs/guides/api/securing-your-api#:~:text=To%20restrict%20access%2C%20enable%20Row,based%20on%20their%20authentication%20token)). With RLS enabled, any query made with the anonymous role (public API) will be restricted by these policies, preventing unauthorized data access ([Securing your API | Supabase Docs](https://supabase.com/docs/guides/api/securing-your-api#:~:text=Any%20table%20without%20RLS%20enabled,access%20to%20your%20project%27s%20data)). Always double-check that every table or RPC has appropriate RLS policies; without RLS, data in that table would be accessible to any anonymous user by default ([Securing your API | Supabase Docs](https://supabase.com/docs/guides/api/securing-your-api#:~:text=Any%20table%20without%20RLS%20enabled,access%20to%20your%20project%27s%20data)).
- **Role-Based Access Control:** Leverage Supabase’s role-based access control (RBAC) or your own application roles to differentiate user privileges ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=integrating%20seamlessly%20with%20Next,at%20the%20individual%20row%20level)). Always enforce role checks on the server (e.g., verify the user’s role or permissions before allowing an admin-only action), not just in the client UI. This ensures that users can only perform actions and access functionalities that they are authorized to use ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=a%20user%20is%20authenticated%2C%20leverage,at%20the%20individual%20row%20level)).
- **Prevent IDOR (Insecure Direct Object References):** Never rely solely on client-side validation for resource access. Whenever a request involves a user-supplied identifier (e.g. a record ID in a URL or form), verify on the server that the authenticated user owns that resource or is allowed to access it. For example, if an API request is made for `/api/orders?orderId=123`, the server should check that order `123` indeed belongs to the current user (or that the user has a role permitting access) before returning it. If not, respond with an authorization error. (In Supabase, you can also enforce this at the database level with RLS policies using `auth.uid()` to match rows to the user.)
- **Principle of Least Privilege:** Always give users and processes the minimum privileges necessary. For instance, do not run every database call with a superuser role; use the anon role (with RLS enforcing permissions) for routine user queries, and only use the Supabase service role key on the server for specific admin tasks ([JWTs | Supabase Docs](https://supabase.com/docs/guides/auth/jwts#:~:text=1.%20,or%20permissions%20specific%20to%20them)). Similarly, restrict what each API route or server function can do based on the invoking user’s role, and never allow normal users to perform admin-only actions. This containment limits the impact of any attempted privilege escalation.

## Secure Configuration & Secrets Management
- **Protect API Keys and Secrets:** Never expose sensitive keys or credentials in frontend code or public repositories. This includes your Supabase **Service Role** key, database connection strings, JWT signing secrets, Stripe secret keys, etc. Store these values in server-side environment variables and **do not** prefix them with `NEXT_PUBLIC_` (as that would expose them to the browser) ([Security concerns with NextJs, Supabase + Prisma ? : r/nextjs](https://www.reddit.com/r/nextjs/comments/1g5cv4j/security_concerns_with_nextjs_supabase_prisma/#:~:text=Pretty%20sure%20you%20can%E2%80%99t%20use,to%20the%20client%20as%20well)). Supabase provides an anonymous public API key (anon key) for use in client-side code, but the service role key (with superadmin privileges) must remain private on the server ([JWTs | Supabase Docs](https://supabase.com/docs/guides/auth/jwts#:~:text=1.%20,or%20permissions%20specific%20to%20them)). Regularly rotate your secret keys to mitigate risk, and never commit them to version control ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=The%20security%20of%20your%20Supabase,store%20and%20manage%20your%20keys)).
- **Environment Variable Safety:** Utilize Next.js environment files (e.g. `.env.local`) or a secrets manager to keep configuration secrets out of your codebase ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=The%20security%20of%20your%20Supabase,store%20and%20manage%20your%20keys)). Double-check that no secrets are inadvertently exposed to the client (for example, by not logging them or embedding them in the HTML). Ensure your version control ignore files (.gitignore) include environment files so you don’t accidentally upload secrets. For production, use secure storage (such as cloud platform secret managers or environment variable configs) to supply these values.
- **Server-Side Only Operations:** Perform sensitive operations on the server (via Next.js API routes or server-side functions), not in client-side code ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=Protecting%20your%20Next,your%20codebase%20and%20remain%20protected)). For example, if you need to interact with Supabase using the service role (or call an external API with a secret key), do that in an API route or server-side function after verifying the user’s identity, rather than directly from React. This keeps credentials and privileged logic hidden on the backend ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=Protecting%20your%20Next,your%20codebase%20and%20remain%20protected)). The frontend should only make requests to these protected endpoints or use the limited anon-key capabilities, ensuring the client cannot directly perform high-privilege actions.
- **Secure Default Configurations:** Apply secure settings by default. Make sure new database tables in Supabase start with RLS enabled (the Supabase dashboard enables it by default for tables created there) and that you explicitly configure any exceptions. In Next.js, consider using the built-in security headers configuration to send headers like `X-Frame-Options`, `X-Content-Type-Options`, `Strict-Transport-Security`, etc. for defense-in-depth ([What are some best practices for cybersecurity in Next.js? : r/nextjs](https://www.reddit.com/r/nextjs/comments/1embc8l/what_are_some_best_practices_for_cybersecurity_in/#:~:text=%E2%80%A2)). Also be cautious with Next.js features like Server Actions or API Routes: do not assume an internal API route is safe from unauthorized access simply because it’s not visible on the client. Protect these routes with authentication middleware (Next.js `middleware.js`) or checks, so that unauthenticated or unauthorized requests are rejected ([Security concerns with NextJs, Supabase + Prisma ? : r/nextjs](https://www.reddit.com/r/nextjs/comments/1g5cv4j/security_concerns_with_nextjs_supabase_prisma/#:~:text=1,actions%2Fserver%20components%20with%20database%20calls)).

## Secure Payment Handling
- **Use Tokenized Payment Methods:** Integrate with a trusted payment provider (e.g. Stripe) to handle credit card data, so that sensitive payment information never directly touches your servers ([Integration security guide | Stripe Documentation](https://docs.stripe.com/security/guide#:~:text=annual%20assessment%20requirements)). For example, use Stripe.js (Elements or Checkout) on the client to collect card details and obtain a token or payment method ID, then send that token to your server to perform the charge. This way, the card data is transmitted securely to Stripe and you only handle tokens, reducing your PCI DSS obligations ([Integration security guide | Stripe Documentation](https://docs.stripe.com/security/guide#:~:text=annual%20assessment%20requirements)).
- **Do Not Store Sensitive Card Data:** Never store full credit card numbers, CVV codes, or bank account numbers in your database. Store only non-sensitive identifiers such as Stripe customer IDs, payment method IDs, or at most the last four digits of a card for display purposes ([stripe.js - Best practice for storing Stripe payments in database? - Stack Overflow](https://stackoverflow.com/questions/49122736/best-practice-for-storing-stripe-payments-in-database#:~:text=In%20general%2C%20you%20can%20store,the%20charge%20id%20or%20equivalent)). Stripe’s API will return non-sensitive info (card brand, last4, expiration date) which isn’t subject to PCI compliance, and it’s safe to store those in your database ([Integration security guide | Stripe Documentation](https://docs.stripe.com/security/guide#:~:text=Out,can%20safely%20store%20Image)). By only storing tokens and partial identifiers, you avoid handling high-risk data while still keeping records you need ([stripe.js - Best practice for storing Stripe payments in database? - Stack Overflow](https://stackoverflow.com/questions/49122736/best-practice-for-storing-stripe-payments-in-database#:~:text=In%20general%2C%20you%20can%20store,the%20charge%20id%20or%20equivalent)).
- **Secure API Keys (Stripe):** Treat your Stripe API keys with care. Use the **publishable key** in the React frontend (for initializing Stripe.js) and keep the **secret key** strictly on the server side ([Stripe API Keys Full Guide 2025: How to Access and Use them?](https://paymentsplugin.com/blog/stripe-api-keys/#:~:text=Publishable%20keys%20are%20used%20in,that%20your%20customers%20interact%20with)) ([Stripe API Keys Full Guide 2025: How to Access and Use them?](https://paymentsplugin.com/blog/stripe-api-keys/#:~:text=Secret%20keys%20are%20used%20on,creating%20charges%20or%20issuing%20refunds)). All sensitive operations (creating charges, subscribing customers, etc.) should be done in your Next.js API routes using the secret key after verifying the request is legitimate. Never expose the secret key in client-side code, as it can perform critical operations like charging cards or issuing refunds ([Stripe API Keys Full Guide 2025: How to Access and Use them?](https://paymentsplugin.com/blog/stripe-api-keys/#:~:text=Secret%20keys%20are%20used%20on,creating%20charges%20or%20issuing%20refunds)).
- **Verify Webhook Authenticity:** If your application relies on webhooks (e.g. Stripe sending payment event notifications to your endpoints), always verify the webhook’s signature to confirm it truly came from Stripe. Use Stripe’s signing secret and their provided libraries or algorithms to check the `Stripe-Signature` header of incoming requests. Only process the webhook if verification passes. This ensures that malicious parties can’t spoof webhook calls. Also, protect your webhook endpoint with appropriate route secret or IP allow-list if possible, and never reveal sensitive data in webhook URLs. *(Remember to handle webhook events idempotently and securely – for example, update your database based on the event object, and no more than necessary.)* ([What are some best practices for cybersecurity in Next.js? : r/nextjs](https://www.reddit.com/r/nextjs/comments/1embc8l/what_are_some_best_practices_for_cybersecurity_in/#:~:text=%2A%20Set%20CORS%2C%20CSP%2C%20X,Policies))
- **PCI Compliance:** Even when using providers like Stripe, maintain basic PCI compliance practices. **Always use HTTPS** on any page that processes payments, to encrypt sensitive data in transit. Ensure that you are not logging or storing any sensitive card details in your application logs. As the business accepting payments, you are responsible for handling customer payments in a PCI-compliant manner (Stripe significantly helps with this, but you must follow their integration guidelines) ([Integration security guide | Stripe Documentation](https://docs.stripe.com/security/guide#:~:text=,annually%20attest%20to%20this%20compliance)). Review Stripe’s documentation and complete any required PCI SAQ (Self-Assessment Questionnaire) if applicable. In short, let Stripe handle as much as possible, but keep your own application’s security around payments airtight.

## Additional Best Practices
- **Error Handling and Information Leakage:** Implement robust error handling that fails safely and doesn’t expose sensitive information. Never return raw error messages or stack traces to users, as they might reveal implementation details or secrets. For example, if a database query fails, respond with a generic error message on the API response, but log the detailed error on the server. Similarly, handle authentication errors in a way that doesn’t divulge whether a username or email exists. By not leaking info, you make it harder for attackers to probe for weaknesses. Also, monitor your application and Supabase logs for unusual activities or errors that could indicate attempted attacks (and respond accordingly) ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=configurations%20to%20identify%20and%20address,logs%20for%20any%20suspicious%20activity)).
- **Rate Limiting and Throttling:** Apply rate limiting on your API endpoints to mitigate abuse. For instance, limit the number of login attempts per IP or user per minute to counter password guessing attacks, and rate-limit generic API calls to prevent denial-of-service or brute force attacks. This can be enforced via middleware or external services, and helps deter automated attacks. You can implement simple in-memory checks, use a library, or leverage infrastructure (NGINX, Cloudflare, etc.) to rate-limit requests ([What are some best practices for cybersecurity in Next.js? : r/nextjs](https://www.reddit.com/r/nextjs/comments/1embc8l/what_are_some_best_practices_for_cybersecurity_in/#:~:text=%2A%20Set%20CORS%2C%20CSP%2C%20X,Policies)). Ensure that your rate limiting strategy is applied consistently to all critical endpoints (login, payment actions, etc.) without affecting legitimate users under normal usage.
- **Keep Dependencies Updated:** Stay up-to-date with the latest security patches for Next.js, React, Supabase, and any other dependencies in your stack ([Securing Your Next.js API Calls with Supabase Service Keys | by Phoebe Theresa Peters | Medium](https://medium.com/@zgza778/securing-your-next-js-api-calls-with-supabase-service-keys-1d6f024b3cd2#:~:text=configurations%20to%20identify%20and%20address,logs%20for%20any%20suspicious%20activity)). Regularly update NPM packages and monitor release notes or vulnerability announcements (for example, subscribe to Next.js and Supabase security updates). Updates often fix known vulnerabilities, so applying them promptly reduces your exposure. Also, update your Supabase configuration or libraries (like `@supabase/supabase-js`) when new security features or fixes are released. 
- **Security Testing and Audit:** Regularly audit your code and configurations for security issues. Use static analysis or linters to catch common mistakes (like usage of `dangerouslySetInnerHTML` or unsanitized data handling). Consider writing automated tests for important security behaviors (e.g., an API test that ensures a normal user cannot access an admin-only endpoint). Periodically, perform penetration testing or use security scanning tools to probe your application for XSS, SQLi, CSRF, and other OWASP Top 10 vulnerabilities. Address any issues found immediately. Additionally, ensure that your build/CI process does not accidentally expose secrets (e.g., in verbose logs) and that any CI-deployed secrets are stored securely.
- **Defense in Depth:** Employ multiple layers of security so that if one layer fails, others still protect the application. For example, even though React escaping protects against most XSS, still implement a CSP and avoid risky practices to cover any gaps. Even with database RLS in place, still verify user permissions in your API routes as a second line of defense. Use HTTP security headers like CSP, X-Frame-Options, X-XSS-Protection, Strict-Transport-Security, etc., to harden the app in browsers ([What are some best practices for cybersecurity in Next.js? : r/nextjs](https://www.reddit.com/r/nextjs/comments/1embc8l/what_are_some_best_practices_for_cybersecurity_in/#:~:text=%E2%80%A2)). Enable SSL/TLS everywhere and consider additional safeguards like Content Security Policy report-uri, Subresource Integrity for external scripts, and so on. This layered approach ensures a mistake in one area doesn’t lead to total compromise.
- **Secure-by-Default Code Generation:** When using AI coding tools (like v0.dev), make security a priority in the prompts. Instruct the AI to produce only **secure-by-default** code – for example, use prepared statements or parameterized queries for any database access, properly encode outputs to prevent XSS, and include checks or tokens for actions that could be sensitive. All example code should follow the above best practices out of the box, with inline comments explaining each security measure implemented. This helps ensure that any generated code is not only functional but also safe, and that future maintainers (or the AI itself) understand the rationale behind each security step.
